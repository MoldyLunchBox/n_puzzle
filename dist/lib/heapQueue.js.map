{"version":3,"file":"heapQueue.js","names":["HeapQueue","constructor","items","maxOpen","cmp","x","y","score","enqueue","elem","heapq","push","length","dequeue","isEmpty","undefined","shift"],"sources":["../../src/lib/heapQueue.js"],"sourcesContent":["\nimport heapq from \"heapq\";\n\n/**\n * prototyping the queue system to manage a list of nodes where \n * every new element is put in correct position to make \n * an ASC list by score value\n */\nexport default class HeapQueue {\n    constructor() {\n        this.items = [];\n        this.maxOpen = 0;\n        this.cmp = function(x, y) { return x.score < y.score }\n    }\n    /**\n     * \n     * @param {Node} elem\n     * @explanation : take a puzzle element of type Node \n     * then put it in the position in the list by its score\n     */\n    enqueue(elem) {\n        heapq.push(this.items, elem, this.cmp);\n        \n        // get complexity in size\n        if (this.items.length > this.maxOpen)\n            this.maxOpen = this.items.length\n    }\n    /**\n     * \n     * @returns return first element and pop it from the list\n     */\n    dequeue() {\n        return this.isEmpty() ? undefined : this.items.shift();\n    }\n\n    /**\n     * \n     * @returns check if the items list is empty\n     */\n    isEmpty() {\n        return !this.items.length;\n    }\n} \n"],"mappings":";;;;;;AACA;AAA0B;AAOX,MAAMA,SAAS,CAAC;EAC3BC,WAAW,GAAG;IACV,IAAI,CAACC,KAAK,GAAG,EAAE;IACf,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,GAAG,GAAG,UAASC,CAAC,EAAEC,CAAC,EAAE;MAAE,OAAOD,CAAC,CAACE,KAAK,GAAGD,CAAC,CAACC,KAAK;IAAC,CAAC;EAC1D;EAOAC,OAAO,CAACC,IAAI,EAAE;IACVC,cAAK,CAACC,IAAI,CAAC,IAAI,CAACT,KAAK,EAAEO,IAAI,EAAE,IAAI,CAACL,GAAG,CAAC;IAGtC,IAAI,IAAI,CAACF,KAAK,CAACU,MAAM,GAAG,IAAI,CAACT,OAAO,EAChC,IAAI,CAACA,OAAO,GAAG,IAAI,CAACD,KAAK,CAACU,MAAM;EACxC;EAKAC,OAAO,GAAG;IACN,OAAO,IAAI,CAACC,OAAO,EAAE,GAAGC,SAAS,GAAG,IAAI,CAACb,KAAK,CAACc,KAAK,EAAE;EAC1D;EAMAF,OAAO,GAAG;IACN,OAAO,CAAC,IAAI,CAACZ,KAAK,CAACU,MAAM;EAC7B;AACJ;AAAC"}