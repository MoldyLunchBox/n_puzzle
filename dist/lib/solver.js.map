{"version":3,"file":"solver.js","names":["Solver","constructor","firstElement","queueType","visited","BloomFilter","queue","HQueue","PQueue","Error","enqueue","add","hash","solution","buildScenario","steps","push","puzzle","score","parent","reverse","start","count","process","hrtime","isEmpty","currentPuzzle","dequeue","wakeUpChilds","isFinal","i","childs","length","child","test","time","cTime","cSize","maxOpen"],"sources":["../../src/lib/solver.js"],"sourcesContent":["import PQueue from \"./priorityQueue\";\nimport HQueue from \"./heapQueue\";\nimport { BloomFilter } from \"bloomfilter\";\n\n// const { log } = console;\n\nexport default class Solver {\n\tconstructor(firstElement, queueType) {\n\t\t// the list of visited nodes so we dont open same node twice\n\t\tthis.visited = new BloomFilter(32 * 1024 * 40000, 32);\n\n\t\t// queue of pending nodes to open\n\t\tif (queueType == \"heapQ\") this.queue = new HQueue();\n\t\telse if (queueType == \"priorityQ\") this.queue = new PQueue();\n\t\telse throw Error(`Please enter correct queue Type [\"heapQ\", \"priorityQ\"]`);\n\n\t\t// pre-append the first element to the queue\n\t\tthis.queue.enqueue(firstElement);\n\t\t// add first puzzle to visited set\n\t\tthis.visited.add(firstElement.hash);\n\t\t// the class property that will store the solution\n\t\tthis.solution = null;\n\t}\n\tasync buildScenario() {\n\t\tlet steps = [];\n\t\twhile (this.solution) {\n\t\t\tsteps.push([this.solution.puzzle, this.solution.score]);\n\t\t\tthis.solution = this.solution.parent;\n\t\t}\n\t\tsteps = steps.reverse();\n\t\treturn steps;\n\t}\n\n\tasync start() {\n\t\tlet count = 0;\n\n\t\t// store the current timestamp in start variable to be used later for execution time calculation\n\t\tconst start = process.hrtime();\n\n\t\t// loop while the queue is not empty and solution is not found yet\n\t\twhile (!this.solution && !this.queue.isEmpty()) {\n\t\t\t// extract the first node in queue and pop it from the queue list\n\t\t\tconst currentPuzzle = this.queue.dequeue();\n\t\t\t// wake up the childs : call a new Node() with the params stored in the childs property\n\t\t\tcurrentPuzzle.wakeUpChilds();\n\t\t\t// increment count (number of loops/nodes)\n\t\t\tcount++;\n\t\t\t// check if the current node is the target/goal node\n\t\t\tif (currentPuzzle.isFinal) {\n\t\t\t\t// store the current node in the this.solution and break\n\t\t\t\tthis.solution = currentPuzzle;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// loop through all the childs in the current node (if any)\n\t\t\t// check if the child visited before and pre-append in the queue if not visited\n\t\t\tfor (let i = 0; i < currentPuzzle.childs.length; i++) {\n\t\t\t\tconst child = currentPuzzle.childs[i];\n\t\t\t\tif (!this.visited.test(child.hash)) {\n\t\t\t\t\t// add the current child node hash to visited set\n\t\t\t\t\tthis.visited.add(child.hash);\n\t\t\t\t\t// add the child node to queue\n\t\t\t\t\tthis.queue.enqueue(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// calc the diff time between start and now, store the output in time\n\t\tconst time = process.hrtime(start);\n\t\t// build a history of steps made from the start puzzle to the goal puzzle with buildScenario() method\n\t\tconst steps = await this.buildScenario();\n\n\t\t// complexity in time : number of nodes opened through the process of solving.\n\t\t// complexity in size : the max number of nodes where pending in Queue at the same time.\n\t\t// time               : time spent to find the solution\n\t\treturn {\n\t\t\tsteps,\n\t\t\tcTime: count,\n\t\t\tcSize: this.queue.maxOpen,\n\t\t\ttime,\n\t\t};\n\t}\n}\n"],"mappings":";;;;;;AAAA;AACA;AACA;AAA0C;AAI3B,MAAMA,MAAM,CAAC;EAC3BC,WAAW,CAACC,YAAY,EAAEC,SAAS,EAAE;IAEpC,IAAI,CAACC,OAAO,GAAG,IAAIC,wBAAW,CAAC,EAAE,GAAG,IAAI,GAAG,KAAK,EAAE,EAAE,CAAC;IAGrD,IAAIF,SAAS,IAAI,OAAO,EAAE,IAAI,CAACG,KAAK,GAAG,IAAIC,kBAAM,EAAE,CAAC,KAC/C,IAAIJ,SAAS,IAAI,WAAW,EAAE,IAAI,CAACG,KAAK,GAAG,IAAIE,sBAAM,EAAE,CAAC,KACxD,MAAMC,KAAK,CAAE,wDAAuD,CAAC;IAG1E,IAAI,CAACH,KAAK,CAACI,OAAO,CAACR,YAAY,CAAC;IAEhC,IAAI,CAACE,OAAO,CAACO,GAAG,CAACT,YAAY,CAACU,IAAI,CAAC;IAEnC,IAAI,CAACC,QAAQ,GAAG,IAAI;EACrB;EACA,MAAMC,aAAa,GAAG;IACrB,IAAIC,KAAK,GAAG,EAAE;IACd,OAAO,IAAI,CAACF,QAAQ,EAAE;MACrBE,KAAK,CAACC,IAAI,CAAC,CAAC,IAAI,CAACH,QAAQ,CAACI,MAAM,EAAE,IAAI,CAACJ,QAAQ,CAACK,KAAK,CAAC,CAAC;MACvD,IAAI,CAACL,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACM,MAAM;IACrC;IACAJ,KAAK,GAAGA,KAAK,CAACK,OAAO,EAAE;IACvB,OAAOL,KAAK;EACb;EAEA,MAAMM,KAAK,GAAG;IACb,IAAIC,KAAK,GAAG,CAAC;IAGb,MAAMD,KAAK,GAAGE,OAAO,CAACC,MAAM,EAAE;IAG9B,OAAO,CAAC,IAAI,CAACX,QAAQ,IAAI,CAAC,IAAI,CAACP,KAAK,CAACmB,OAAO,EAAE,EAAE;MAE/C,MAAMC,aAAa,GAAG,IAAI,CAACpB,KAAK,CAACqB,OAAO,EAAE;MAE1CD,aAAa,CAACE,YAAY,EAAE;MAE5BN,KAAK,EAAE;MAEP,IAAII,aAAa,CAACG,OAAO,EAAE;QAE1B,IAAI,CAAChB,QAAQ,GAAGa,aAAa;QAC7B;MACD;MAGA,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,aAAa,CAACK,MAAM,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;QACrD,MAAMG,KAAK,GAAGP,aAAa,CAACK,MAAM,CAACD,CAAC,CAAC;QACrC,IAAI,CAAC,IAAI,CAAC1B,OAAO,CAAC8B,IAAI,CAACD,KAAK,CAACrB,IAAI,CAAC,EAAE;UAEnC,IAAI,CAACR,OAAO,CAACO,GAAG,CAACsB,KAAK,CAACrB,IAAI,CAAC;UAE5B,IAAI,CAACN,KAAK,CAACI,OAAO,CAACuB,KAAK,CAAC;QAC1B;MACD;IACD;IAEA,MAAME,IAAI,GAAGZ,OAAO,CAACC,MAAM,CAACH,KAAK,CAAC;IAElC,MAAMN,KAAK,GAAG,MAAM,IAAI,CAACD,aAAa,EAAE;IAKxC,OAAO;MACNC,KAAK;MACLqB,KAAK,EAAEd,KAAK;MACZe,KAAK,EAAE,IAAI,CAAC/B,KAAK,CAACgC,OAAO;MACzBH;IACD,CAAC;EACF;AACD;AAAC"}