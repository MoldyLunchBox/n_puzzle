const fs = require('fs');
const { exit, mainModule } = require('process');
const readline = require('readline');
const { kMaxLength } = require('buffer');
const { log } = console;



function heuristic_manhattan(position0, position1) {
    let d1 = Math.abs(position1.x - position0.x);
    let d2 = Math.abs(position1.y - position0.y);
    return d1 + d2;
}

function generateGoal(mapSize, goalType){
    goal = ""
    for (let i = 0; i < mapSize; i++){
        for (let j = 0; j < mapSize; j++){
            if (i != mapSize - 1 ||  j != mapSize - 1){

                goal += i * mapSize + j + 1
                goal += '.'
            }
            else 
                goal += '0'
        }
    }
    return goal
}


function isSolvable(initial, goal, size = 3) {
    // Helper function to count inversions in a given state
    let initialInt = initial.map((e)=> e.map((el)=> parseInt(el)))
    let goalInt = goal.map((e)=> e.map((el)=> parseInt(el)))
    function countInversions(state, size) {
      let inversions = 0;
      for (let i = 0; i < size * size; i++) {
        for (let j = i + 1; j < size * size; j++) {
          if (state[i] && state[j] && state[i] > state[j]) {
            inversions++;
          }
        }
      }
      return inversions;
    }
    // Count inversions in initial and goal states
    let initialInversions = countInversions(initialInt, size);
    let goalInversions = countInversions(goalInt, size);
    // Check if the puzzle is solvable by comparing inversions
    if ((initialInversions % 2 === 0) === (goalInversions % 2 === 0)) {
      return true;
    } else {
      return false;
    }
  }



class State {
    constructor(stateMap, parent, heuristicName, greedy = false, uniform = false) {
       
        this.stateMap = stateMap;
        this.parent = parent
        this.heuristicToUse = heuristicName
        this.level = (parent == undefined ?  -1 : parent.level) + 1
        this.hash = [].concat.apply([], this.stateMap).join(".");
        this.score = (uniform ? 0 : this.calculateScore())  + this.level
    
 
    }
    // parseInt
    calculateScore() {
       
        this.heuristic(this.heuristicToUse)
        return this.heuristic(this.heuristicToUse)
    }
    heuristic(heur) {
       
        const goal = generateGoal(this.stateMap.length, "").split(".")
        const manhattan = () => {
            let score = 0
            for (let i = 0; i < this.stateMap.length; i++) {

                for (let j = 0; j < this.stateMap.length; j++) {

                    const goalNumber = goal[i * this.stateMap.length + j]

                    const targetCord = getCoordInMap(this.stateMap, goalNumber)
                    const position0 = { 'x': j, 'y': i }
                    const position1 = {
                        'x': targetCord.x,
                        'y': targetCord.y
                    }
                    const d1 = Math.abs(position1.x - position0.x);
                    const d2 = Math.abs(position1.y - position0.y);

                    score += d1 + d2;

                }
            }
            return score
        }

        const missPlaced = () =>  {
            let counter = 0
            for (let i = 0; i < this.stateMap.length; i++) {
                for (let j = 0; j < this.stateMap.length; j++) {
                    const goalNumber = goal[i * this.stateMap.length + j]
                    if (goalNumber !== this.stateMap[i][j])
                        counter++
                }
            }

            return counter
        }
        const heurs = {
            'manhattan': manhattan,
            'missPlaced' : missPlaced
        }
        return heurs[heur]()
    }    
    generateSubStates() {
        let zeroIdx = 0
        let possibleStates = []
        let size = this.stateMap[0].length
        goal = strToArr(goal, size )
        for (let i = 0; i < size; i++) {
            for (let x = 0; x < size; x++) {
                if (this.stateMap[i][x] == '0') {
                    zeroIdx = { i, x }
                    if (this.stateMap[i - 1]?.[x]) {
                       
                        let  puz = swapWithZero(this.stateMap, zeroIdx, { 'i': i - 1, 'x': x })
                        let good = isSolvable(puz, goal, puz.length)
                    
                        if (good)
                            possibleStates.push(puz) 
                        
                    }
                    if (this.stateMap[i + 1]?.[x]) {
                        let puz = swapWithZero(this.stateMap, zeroIdx, { 'i': i + 1, 'x': x })
                        let good = isSolvable(puz, goal, puz.length)
                     
                        if (good)
                            possibleStates.push(puz) 
                        
                    }
                    if (this.stateMap[i]?.[x + 1]) {
                        let puz = swapWithZero(this.stateMap, zeroIdx, { 'i': i, 'x': x + 1 })
                        let good = isSolvable(puz, goal, puz.length)
                      
                        if (good)
                            possibleStates.push(puz) 
                        
                    }
                    if (this.stateMap[i]?.[x - 1]) {
                        let puz = swapWithZero(this.stateMap, zeroIdx, { 'i': i, 'x': x - 1 })
                        let good = isSolvable(puz, goal, puz.length)
                    
                        if (good)
                            possibleStates.push(puz) 
                        
                    }
                    break
                }
            }
        }
    
        const subs = possibleStates.map(pzl => new State(pzl, this, this.heuristicToUse))
  
        return subs
    }
  
}



var size = 0
var openSet = new Map()
var closedSet = new Map()




/**
 * 
 * @param {map as array of arrays} stateMap 
 * @returns  a string in which each element is seperated by a dot
 */
function stateToStr(stateMap) {
    return [].concat.apply([], stateMap).join(".");
}

/**
 * 
 * @param {map array} arr 
 * @returns -1 if the values in the map are not digits 
 */
function puzzle_verifier(arr) {
    i = 0;
    j = 0
    while (arr[i]) {
        while (arr[i][j]) {
            if ((arr[i][j] < '0' || arr[i][j] > '9'))
                return -1
            j++;
        }
        j = 0;
        i++;
    }

    return 0;
}




function copyObj(ubj) {
    return JSON.parse(JSON.stringify(ubj))
}

function getCoordInMap(map, target) {
   
    for (let i = 0; i < map.length; i++) {
        for (let j = 0; j < map.length; j++) {
           
            if (map[i][j] === target)
                return { x: j, y: i }
        }
    }
    return false
}


function state_to_arr(stateSet) {
    ret = []
    for (let [key, value] of openSet.entries()) {
        ret.push(value)
    }
    return ret
}

function strToArr(mapStr, size){
    map =  mapStr.split('.')
    mapArr = [[],[],[]]
    for (let i = 0; i < size; i++){
        for (let j = 0; j < size; j++){
            if (map[i * size + j])
                mapArr[i].push(map[i * size + j])
            }
        }
    return (mapArr)
}

 function swapWithZero(stateMap, zeroIdx, move) {
    const stateMapCopy = copyObj(stateMap)
    const tmp = stateMapCopy[move.i][move.x]

    stateMapCopy[move.i][move.x] = '0'
    stateMapCopy[zeroIdx.i][zeroIdx.x] = tmp

    return stateMapCopy
}


 function main() {
    console.clear()
    var stateMap = [ [ '8', '1', '4' ], [ '3', '0', '2' ], [ '6', '5', '7' ] ]
    size = stateMap[0].length
    const state = new State(stateMap, null, 'missPlaced', false, false)
    openSet.set(state.hash, state)
    let solution = null
    let closedArr = []
    array = state_to_arr(openSet)
    let goal = strToArr(generateGoal(array[0].stateMap.length, "ok"), 3)
    
    while (array.length) {
        
        
        if (!isSolvable(array[0].stateMap, goal, 3))
        {
            return(false)
        }
        let subStates = []
        if (array[0].hash == goal) {
            solution = array[0]
            break
        }
        // break
        log(array[0])
        subStates = array[0].generateSubStates()
        if (subStates.find(l => l.hash === goal)) {
            solution = subStates.find(l => l.hash === goal)
            break
        }


        array = [
            ...array,
            ...subStates.filter(l => !closedArr.includes(l) && !array.find(el => el.hash == l.hash))
        ]
        closedArr = [...new Set([...closedArr, array[0].hash])]
      
        array = array.filter(l => !closedArr.includes(l.hash))

        array.sort((a, b) => a.score - b.score)
        // console.clear()
        



    }
    let steps = 0
    if (solution) {
        return true
    }
    else return false
}
main();

